#!/bin/bash
# A simple utility to display all 256 terminal colors.

# Exit immediately if a command exits with a non-zero status.
set -e
# The return value of a pipeline is the status of the last command to exit with a non-zero status.
set -o pipefail

# Colors & Styles
C_RED=$'\033[31m'
C_L_RED=$'\033[31;1m'
C_L_BLUE=$'\033[34m'
C_GRAY=$'\033[38;5;244m'
T_RESET=$'\033[0m'
T_BOLD=$'\033[1m'
T_ULINE=$'\033[4m'

# Icons
T_ERR_ICON="[${T_BOLD}${C_RED}✗${T_RESET}]"

# Logging
printMsg() { printf '%b\n' "$1"; }
printErrMsg() { printMsg "${T_ERR_ICON}${T_BOLD}${C_L_RED} ${1} ${T_RESET}"; }

# Banner Utils
strip_ansi_codes() {
    local s="$1"; local esc=$'\033'
    if [[ "$s" != *"$esc"* ]]; then echo -n "$s"; return; fi
    local pattern="$esc\\[[0-9;]*[a-zA-Z]"
    while [[ $s =~ $pattern ]]; do s="${s/${BASH_REMATCH[0]}/}"; done
    echo -n "$s"
}

_truncate_string() {
    local input_str="$1"; local max_len="$2"; local trunc_char="${3:-…}"; local trunc_char_len=${#trunc_char}
    local stripped_str; stripped_str=$(strip_ansi_codes "$input_str"); local len=${#stripped_str}
    if (( len <= max_len )); then echo -n "$input_str"; return; fi
    local truncate_to_len=$(( max_len - trunc_char_len )); local new_str=""; local visible_count=0; local i=0; local in_escape=false
    while (( i < ${#input_str} && visible_count < truncate_to_len )); do
        local char="${input_str:i:1}"; new_str+="$char"
        if [[ "$char" == $'\033' ]]; then in_escape=true; elif ! $in_escape; then (( visible_count++ )); fi
        if $in_escape && [[ "$char" =~ [a-zA-Z] ]]; then in_escape=false; fi; ((i++))
    done
    echo -n "${new_str}${trunc_char}"
}

generate_banner_string() {
    local text="$1"; local total_width=70; local prefix="┏"; local line
    printf -v line '%*s' "$((total_width - 1))"; line="${line// /━}"; printf '%s' "${C_L_BLUE}${prefix}${line}${T_RESET}"; printf '\r'
    local text_to_print; text_to_print=$(_truncate_string "$text" $((total_width - 3)))
    printf '%s' "${C_L_BLUE}${prefix} ${text_to_print} ${T_RESET}"
}

printBanner() { printMsg "$(generate_banner_string "$1")"; }

# --- Script Functions ---

print_usage() {
    printBanner "Color Palette Viewer"
    printMsg "A simple utility to display all 256 terminal colors."
    printMsg "\n${T_ULINE}Usage:${T_RESET}"
    printMsg "  $(basename "$0") [-b] [-c] [-C <color>] [-s <text>] [-g <mode>] [-h]"
    printMsg "\n${T_ULINE}Options:${T_RESET}"
    printMsg "  ${C_L_BLUE}-b${T_RESET}            Display colors as solid blocks instead of numbers."
    printMsg "  ${C_L_BLUE}-c${T_RESET}            Output color codes in a copy-paste friendly format."
    printMsg "  ${C_L_BLUE}-C <color>${T_RESET}    Generate code for a specific color number (0-255)."
    printMsg "  ${C_L_BLUE}-s <text>${T_RESET}     Sample text to use with -c or -C."
    printMsg "  ${C_L_BLUE}-g <mode>${T_RESET}   Display 'fg' (foreground) or 'bg' (background) colors. Default: fg."
    printMsg "  ${C_L_BLUE}-h${T_RESET}            Show this help message."
    printMsg "\n${T_ULINE}Examples:${T_RESET}"
    printMsg "  ${C_GRAY}# Show background colors as blocks${T_RESET}"
    printMsg "  $(basename "$0") -g bg -b"
    printMsg "  ${C_GRAY}# List color codes for copying${T_RESET}"
    printMsg "  $(basename "$0") -c"
    printMsg "  ${C_GRAY}# Generate code for color 129 with custom text${T_RESET}"
    printMsg "  $(basename "$0") -C 129 -s 'Hello World'"
}

# Choose a legible foreground color (black or white) for a given background color index.
# This is based on a pre-calculated list of colors with high perceived luminance.
get_contrasting_fg_color() {
    local bg_color=$1
    # A set of all "light" colors in the 256-color palette where black (0) text is more readable.
    # This string-based set is a fast way to check for membership in bash.
    # The list was generated by calculating the luminance of each color.
    local LIGHT_COLORS_SET="|7|10|11|12|13|14|15|49|50|51|83|84|85|86|87|118|119|120|121|122|123|153|154|155|156|157|158|159|189|190|191|192|193|194|195|221|222|223|224|225|226|227|228|229|230|231|247|248|249|250|251|252|253|254|255|"

    if [[ "$LIGHT_COLORS_SET" == *"|$bg_color|"* ]]; then
        echo 0 # Black
    else
        echo 15 # Bright White
    fi
}

# Displays the full 256-color grid.
# Usage: display_color_grid <mode> <use_blocks>
display_color_grid() {
    local mode="$1"
    local use_blocks="$2"
    local block_char="██"

    # Loop through all 256 colors
    for i in {0..255}; do
        if [[ "$mode" == "bg" ]]; then
            if (( use_blocks == 1 )); then
                printf "\x1b[48;5;%dm%-4s" "$i" "$block_char"
            else
                local fg_color; fg_color=$(get_contrasting_fg_color "$i")
                printf "\x1b[48;5;%dm\x1b[38;5;%dm%3d " "$i" "$fg_color" "$i"
            fi
        else # mode == "fg"
            if (( use_blocks == 1 )); then
                printf "\x1b[38;5;%dm%-4s" "$i" "$block_char"
            else
                printf "\x1b[38;5;%dm%3d " "$i" "$i"
            fi
        fi

        # Group items into 16 per line for a more grid-like view
        if (( (i + 1) % 16 == 0 )); then
            printf "%b\n" "$T_RESET"
        fi
    done

    # Reset the color at the end in case the total isn't a multiple of 16
    printf "%b\n" "$T_RESET"
}

# Displays a list of color codes for easy copying.
# Usage: display_code_list <mode> <sample_text>
display_code_list() {
    local mode="$1"
    local sample_text="$2"
    local display_text="${sample_text:-Sample}"

    for i in {0..255}; do
        if [[ "$mode" == "bg" ]]; then
            local fg_color; fg_color=$(get_contrasting_fg_color "$i")
            printf "BG_%03d=$'\\\\033[48;5;%dm' # \x1b[48;5;%dm\x1b[38;5;%dm %s \x1b[0m\n" "$i" "$i" "$i" "$fg_color" "$display_text"
        else
            printf "C_%03d=$'\\\\033[38;5;%dm' # \x1b[38;5;%dm %s \x1b[0m\n" "$i" "$i" "$i" "$display_text"
        fi
    done
}

# Displays details for a single, specific color.
# Usage: display_specific_color <color_num> <mode> <sample_text>
display_specific_color() {
    local specific_color="$1"
    local mode="$2"
    local sample_text="$3"
    local text="${sample_text:-Sample Text}"
    local color_code=""
    local var_prefix="C"

    if [[ "$mode" == "bg" ]]; then
        color_code="48;5;${specific_color}"
        var_prefix="BG"
    else
        color_code="38;5;${specific_color}"
        var_prefix="C"
    fi

    printMsg "${T_BOLD}Variable Definition:${T_RESET}"
    printf "%s_%03d=$'\\\\033[%sm'\n" "$var_prefix" "$specific_color" "$color_code"
    echo

    printMsg "${T_BOLD}Bash Command:${T_RESET}"
    printf 'echo -e "\\033[%sm%s\\033[0m"\n' "$color_code" "$text"
    echo

    printMsg "${T_BOLD}Sample Output:${T_RESET}"
    if [[ "$mode" == "bg" ]]; then
         local fg_color; fg_color=$(get_contrasting_fg_color "$specific_color")
         printf "\x1b[%sm\x1b[38;5;%dm%s\x1b[0m\n" "$color_code" "$fg_color" "$text"
    else
         printf "\x1b[%sm%s\x1b[0m\n" "$color_code" "$text"
    fi
}

main() {
    # Default values
    local use_blocks=0
    local show_codes=0
    local mode="fg"
    local specific_color=""
    local sample_text=""

    # Process arguments using getopts
    while getopts ":bg:chC:s:" opt; do
        case ${opt} in
            b) use_blocks=1 ;;
            c) show_codes=1 ;;
            g) mode="$OPTARG" ;;
            C) specific_color="$OPTARG" ;;
            s) sample_text="$OPTARG" ;;
            h) print_usage; exit 0 ;;
            \?) printErrMsg "Invalid option: -$OPTARG" >&2; print_usage; exit 1 ;;
            :) printErrMsg "Option -$OPTARG requires an argument." >&2; print_usage; exit 1 ;;
        esac
    done

    if [[ "$mode" != "fg" && "$mode" != "bg" ]]; then
        printErrMsg "Invalid mode for -g: '${mode}'. Must be 'fg' or 'bg'." >&2
        print_usage
        exit 1
    fi

    if [[ -n "$specific_color" ]]; then
        if ! [[ "$specific_color" =~ ^[0-9]+$ ]] || (( specific_color < 0 || specific_color > 255 )); then
             printErrMsg "Color number must be between 0 and 255." >&2
             exit 1
        fi
        display_specific_color "$specific_color" "$mode" "$sample_text"
    elif (( show_codes == 1 )); then
        display_code_list "$mode" "$sample_text"
    else
        display_color_grid "$mode" "$use_blocks"
    fi
}

# This block will only run when the script is executed directly, not when sourced.
if [[ "${BASH_SOURCE[0]}" == "$0" ]]; then
    main "$@"
fi