#!/bin/bash
# A simple utility to display all 256 terminal colors.

# Exit immediately if a command exits with a non-zero status.
set -e
# The return value of a pipeline is the status of the last command to exit with a non-zero status.
set -o pipefail

# Source common utilities for colors and functions
# shellcheck source=./shared.sh
# shellcheck disable=SC1091
if ! source "$(dirname "${BASH_SOURCE[0]}")/shared.sh"; then
    echo "Error: Could not source shared.sh. Make sure it's in the same directory." >&2
    exit 1
fi

# --- Script Functions ---

print_usage() {
    printBanner "Color Palette Viewer"
    printMsg "A simple utility to display all 256 terminal colors."
    printMsg "\n${T_ULINE}Usage:${T_RESET}"
    printMsg "  $(basename "$0") [-b] [-g <mode>] [-h]"
    printMsg "\n${T_ULINE}Options:${T_RESET}"
    printMsg "  ${C_L_BLUE}-b${T_RESET}            Display colors as solid blocks instead of numbers."
    printMsg "  ${C_L_BLUE}-g <mode>${T_RESET}   Display 'fg' (foreground) or 'bg' (background) colors. Default: fg."
    printMsg "  ${C_L_BLUE}-h${T_RESET}            Show this help message."
    printMsg "\n${T_ULINE}Examples:${T_RESET}"
    printMsg "  ${C_GRAY}# Show background colors as blocks${T_RESET}"
    printMsg "  $(basename "$0") -g bg -b"
}

# Choose a legible foreground color (black or white) for a given background color index.
# This is based on a pre-calculated list of colors with high perceived luminance.
get_contrasting_fg_color() {
    local bg_color=$1
    # A set of all "light" colors in the 256-color palette where black (0) text is more readable.
    # This string-based set is a fast way to check for membership in bash.
    # The list was generated by calculating the luminance of each color.
    local LIGHT_COLORS_SET="|7|10|11|12|13|14|15|49|50|51|83|84|85|86|87|118|119|120|121|122|123|153|154|155|156|157|158|159|189|190|191|192|193|194|195|221|222|223|224|225|226|227|228|229|230|231|247|248|249|250|251|252|253|254|255|"

    if [[ "$LIGHT_COLORS_SET" == *"|$bg_color|"* ]]; then
        echo 0 # Black
    else
        echo 15 # Bright White
    fi
}

# --- Main Script ---

# Default values
use_blocks=0
mode="fg"

# Process arguments using getopts
while getopts ":bg:h" opt; do
    case ${opt} in
        b) use_blocks=1 ;;
        g) mode="$OPTARG" ;;
        h) print_usage; exit 0 ;;
        \?) printErrMsg "Invalid option: -$OPTARG" >&2; print_usage; exit 1 ;;
        :) printErrMsg "Option -$OPTARG requires an argument." >&2; print_usage; exit 1 ;;
    esac
done

if [[ "$mode" != "fg" && "$mode" != "bg" ]]; then
    printErrMsg "Invalid mode for -g: '${mode}'. Must be 'fg' or 'bg'." >&2
    print_usage
    exit 1
fi

block_char="██"

# Loop through all 256 colors
for i in {0..255}; do
    if [[ "$mode" == "bg" ]]; then
        if (( use_blocks == 1 )); then
            printf "\x1b[48;5;%dm%-4s" "$i" "$block_char"
        else
            fg_color=$(get_contrasting_fg_color "$i")
            printf "\x1b[48;5;%dm\x1b[38;5;%dm%3d " "$i" "$fg_color" "$i"
        fi
    else
        if (( use_blocks == 1 )); then
            printf "\x1b[38;5;%dm%-4s" "$i" "$block_char"
        else
            printf "\x1b[38;5;%dm%3d " "$i" "$i"
        fi
    fi

    # Group items into 16 per line for a more grid-like view
    if (( (i + 1) % 16 == 0 )); then
        printf "%b\n" "$T_RESET"
    fi
done

# Reset the color at the end
printf "%b\n" "$T_RESET"