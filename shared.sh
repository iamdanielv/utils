#!/bin/bash
export C_RED='\e[31m'
export C_GREEN='\e[32m'
export C_YELLOW='\e[33m'
export C_BLUE='\e[34m'
export C_MAGENTA='\e[35m'
export C_CYAN='\e[36m'
export C_WHITE='\e[37m'
export C_GRAY='\e[90m'
export C_L_RED='\e[31;1m'
export C_L_GREEN='\e[32;1m'
export C_L_YELLOW='\e[33;1m'
export C_L_BLUE='\e[34;1m'
export C_L_MAGENTA='\e[35;1m'
export C_L_CYAN='\e[36;1m'
export C_L_WHITE='\e[37;1m'
export C_L_GRAY='\e[90m'

# Background Colors
export BG_BLACK='\e[40;1m'
export BG_RED='\e[41;1m'
export BG_GREEN='\e[42;1m'
export BG_YELLOW='\e[43;1m'
export BG_BLUE='\e[44;1m'

# Text Colors
export C_BLACK='\e[30;1m'

export T_RESET='\e[0m'
export T_BOLD='\e[1m'
export T_ULINE='\e[4m'
export T_REVERSE='\e[7m'
export T_CLEAR_LINE='\e[K'
export T_CURSOR_HIDE='\e[?25l'
export T_CURSOR_SHOW='\e[?25h'

export T_ERR="${T_BOLD}\e[31;1m"
export T_ERR_ICON="[${T_BOLD}${C_RED}✗${T_RESET}]"

export T_OK_ICON="[${T_BOLD}${C_GREEN}✓${T_RESET}]"
export T_INFO_ICON="[${T_BOLD}${C_YELLOW}i${T_RESET}]"
export T_WARN_ICON="[${T_BOLD}${C_YELLOW}!${T_RESET}]"
export T_QST_ICON="[${T_BOLD}${C_L_CYAN}?${T_RESET}]"

export DIV="-------------------------------------------------------------------------------"

# Key Codes
export KEY_ESC=$'\e'
export KEY_UP=$'\e[A'
export KEY_DOWN=$'\e[B'
export KEY_RIGHT=$'\e[C'
export KEY_LEFT=$'\e[D'
export KEY_ENTER="ENTER"
export KEY_TAB=$'\t'
export KEY_BACKSPACE=$'\x7f' # ASCII DEL character for backspace
export KEY_HOME=$'\e[H'
export KEY_END=$'\e[F'
export KEY_DELETE=$'\e[3~'

# --- Banner Control ---
# This logic helps determine if a script is being called by another script in this project.
# The first script to source this file will set the entry-level shell level ($SHLVL).
# Any script *executed* by that first script will run in a new shell, which will have a
# higher SHLVL. This allows us to print a simpler banner for nested script calls.
if [[ -z "$SCRIPT_EXEC_ENTRY_SHLVL" ]]; then
    export SCRIPT_EXEC_ENTRY_SHLVL=$SHLVL
fi

# Generates a banner string based on the script's execution depth (SHLVL).
# The generated string includes newlines appropriate for the banner type,
# but no final newline. This allows banner logic to be reused without direct printing.
# Usage: local banner_str; banner_str=$(generate_banner_string "My Title")
function generate_banner_string() {
    local prompt="$1"
    if [[ "$SHLVL" -gt "$SCRIPT_EXEC_ENTRY_SHLVL" ]]; then
        # H2-style banner for nested calls
        echo -n -e "${C_BLUE}${T_BOLD}--- ${prompt} ---${T_RESET}"
    else
        # H1-style banner for top-level calls
        echo -n -e "${C_L_BLUE}+ ${prompt}\n${DIV}${T_RESET}"
    fi
}

function printTestSectionHeader() {
  printMsg "\n${T_ULINE}${C_L_WHITE}    ${1}${T_RESET}"
}

function printBanner() {
  # Prints a banner generated by the shared banner logic.
  printMsg "$(generate_banner_string "$1")"
}

function printMsg() {
  echo -e "${1}"
}

function printMsgNoNewline() {
  echo -n -e "${1}"
}

function printDatedMsgNoNewLine() {
  echo -n -e "$(getPrettyDate) ${1}"
}

function printErrMsg() {
  printMsg "${T_ERR_ICON}${T_ERR} ${1} ${T_RESET}"
}

function printOkMsg() {
  printMsg "${T_OK_ICON} ${1}${T_RESET}"
}

function printInfoMsg() {
  printMsg "${T_INFO_ICON} ${1}${T_RESET}"
}

function printWarnMsg() {
  printMsg "${T_WARN_ICON} ${1}${T_RESET}"
}

function getFormattedDate() {
  date +"%Y-%m-%d %I:%M:%S"
}

function getPrettyDate() {
  echo "${C_BLUE}$(getFormattedDate)${T_RESET}"
}

# Clears the current line and returns the cursor to the start.
clear_current_line() {
    # \e[2K: clear entire line
    # \r: move cursor to beginning of the line
    echo -ne "\e[2K\r" >/dev/tty
}

# Clears a specified number of lines above the current cursor position.
# Usage: clear_lines_up [number_of_lines]
clear_lines_up() {
    local lines=${1:-1} # Default to 1 line if no argument is provided
    for ((i = 0; i < lines; i++)); do
        # \e[1A: move cursor up one line
        # \e[2K: clear entire line
        echo -ne "\e[1A\e[2K"
    done
    echo -ne "\r" # Move cursor to the beginning of the line
} >/dev/tty

# Clears a specified number of lines from the cursor position downwards.
# The cursor ends up back at its starting position.
# Usage: clear_lines_down [number_of_lines]
clear_lines_down() {
    local lines=${1:-1}
    if (( lines <= 0 )); then return; fi

    for ((i = 0; i < lines; i++)); do
        # \e[2K: clear entire line
        # \n: move to next line
        echo -ne "\e[2K\n"
    done
    # \e[<N>A: move cursor up N lines
    echo -ne "\e[${lines}A"
} >/dev/tty

# Moves the cursor up a specified number of lines without clearing them.
# This is used for flicker-free updates of multi-line content.
# Usage: move_cursor_up [number_of_lines]
move_cursor_up() {
    local lines=${1:-1}
    # Redirect all output of this function to /dev/tty to ensure it works
    # even when the script's stdout is being captured (e.g., in command substitution).
    if (( lines > 0 )); then
        # Using a loop of "up 1" can be more reliable in some terminals
        # than a single "up N" command, which helps prevent screen tearing.
        for ((i = 0; i < lines; i++)); do echo -ne "\e[1A"; done
    fi
    echo -ne "\r" # Move cursor to the beginning of the line
} >/dev/tty

# Formats Tab-Separated Value (TSV) data into a clean, aligned table.
# This function correctly handles cells that contain ANSI color codes.
# It reads from stdin and takes an optional indent prefix as an argument.
# Usage:
#   echo -e "HEADER1\tHEADER2\nValue1\tValue2" | format_tsv_as_table "  "
# To right-align column 2:
#   ... | format_tsv_as_table "  " "2"
format_tsv_as_table() {
    local indent="${1:-}" # Optional indent prefix
    local right_align_cols="${2:-}" # Optional string of column numbers to right-align, e.g., "2 3"
    local padding=4      # Spaces between columns

    # Use a two-pass awk script for perfect alignment.
    # 1. The first pass calculates the maximum *visible* width of each column.
    # 2. The second pass prints each cell, followed by the required padding.
    # This approach is necessary to correctly handle ANSI color codes, which have
    # a non-zero character length but zero visible width.
    awk -v indent="$indent" -v padding="$padding" -v right_align_str="$right_align_cols" '
        # Function to calculate the visible length of a string by removing ANSI codes.
        # temp_s is declared as a parameter to make it a local variable,
        # which is the portable way to do this in awk.
        function visible_length(s, temp_s) {
            temp_s = s # Copy the string to a local variable.
            gsub(/\x1b\[[0-9;?]*[a-zA-Z]/, "", temp_s)
            return length(temp_s)
        }

        BEGIN {
            FS="\t"
            # Parse the right_align_str into an associative array for quick lookups.
            split(right_align_str, col_map, " ")
            for (i in col_map) { right_align[col_map[i]] = 1 }
        }

        # First pass: Read all data and calculate max visible width for each column.
        {
            for(i=1; i<=NF; i++) {
                len = visible_length($i)
                if(len > max_width[i]) { max_width[i] = len }
            }
            data[NR] = $0 # Store the original line with colors.
        }

        # Second pass: Print the formatted table.
        END {
            for(row=1; row<=NR; row++) {
                printf "%s", indent
                num_fields = split(data[row], fields, FS) # Split the original line to preserve colors.
                # Skip processing for lines that are completely empty. This handles trailing newlines from echo.
                if (num_fields == 1 && fields[1] == "") { continue }
                for(col=1; col<=num_fields; col++) {
                    align_pad = max_width[col] - visible_length(fields[col])

                    if (right_align[col]) {
                        # Right-align: alignment padding, then content.
                        for (p=0; p<align_pad; p++) { printf " " }
                        printf "%s", fields[col]
                    } else {
                        # Left-align: content, then alignment padding.
                        printf "%s", fields[col]
                        for (p=0; p<align_pad; p++) { printf " " }
                    }

                    # Print inter-column padding, but not for the last column.
                    if (col < num_fields) {
                        for (p=0; p<padding; p++) { printf " " }
                    }
                }
                printf "\n"
            }
        }
    '
}

# Reads a single character from stdin without needing Enter.
# It correctly handles the ESC key, distinguishing it from arrow key escape sequences.
# It also explicitly identifies the Enter key.
# Returns the character read, or the value of KEY_ENTER for the enter key.
# Usage:
#   local choice
#   choice=$(read_single_char)
#   if [[ "$choice" == "$KEY_ENTER" ]]; then
#     # Handle enter
#   fi
read_single_char() {
    local char
    local seq
    # -s: silent, -n 1: one char, -r: raw
    IFS= read -rsn1 char
    # Check for Enter key, which read consumes but returns as an empty string.
    if [[ -z "$char" ]]; then
        echo "$KEY_ENTER"
        return
    fi
    # If the character is ESC, check for a following sequence.
    if [[ "$char" == "$KEY_ESC" ]]; then
        # Try to read the rest of an escape sequence with a short timeout.
        # This loop will continue to read as long as characters are
        # available in the input buffer without a significant delay.
        # This is more robust than reading a fixed number of characters.
        while IFS= read -rsn1 -t 0.001 seq; do
            char+="$seq"
        done
    fi
    echo "$char"
}

# --- Error Handling & Traps ---

# Centralized error handler function.
# This function is triggered by the 'trap' command on any error when 'set -e' is active.
script_error_handler() {
    local exit_code=$? # Capture the exit code immediately!
    trap - ERR # Disable the trap to prevent recursion if the handler itself fails.
    local line_number=$1
    local command="$2"
    # BASH_SOURCE[1] is the path to the script that sourced this file.
    local script_path="${BASH_SOURCE[1]:-${BASH_SOURCE[0]}}"
    local script_name
    script_name=$(basename "$script_path")

    echo # Add a newline for better formatting before the error.
    printErrMsg "A fatal error occurred."
    printMsg "    Script:     ${C_L_BLUE}${script_name}${T_RESET}"
    printMsg "    Line:       ${C_L_YELLOW}${line_number}${T_RESET}"
    printMsg "    Command:    ${C_L_CYAN}${command}${T_RESET}"
    printMsg "    Exit Code:  ${C_RED}${exit_code}${T_RESET}"
    echo
}

# Function to handle Ctrl+C (SIGINT)
script_interrupt_handler() {
    trap - INT # Disable the trap to prevent recursion.
    clear
    printMsg "${T_WARN_ICON} ${C_L_YELLOW}Operation cancelled by user.${T_RESET}"
    # Exit with a status code indicating cancellation (130 is common for Ctrl+C).
    exit 130
}

# Set the trap. This will call our handler function whenever a command fails.
# The arguments passed to the handler are the line number and the command that failed.
# shellcheck disable=SC2064
trap 'script_error_handler $LINENO "$BASH_COMMAND"' ERR
trap 'script_interrupt_handler' INT

# --- Prerequisite & Sanity Checks ---

# Internal helper to check for a command's existence without output.
# Returns 0 if found, 1 otherwise.
_check_command_exists() {
    command -v "$1" &>/dev/null
}

# Checks for command-line tools
# Exits with an error if any of the specified commands are not found.
# Usage: prereq_checks "command1" "command2" "..."
prereq_checks() {
    local missing_commands=()
    printMsgNoNewline "${T_INFO_ICON} Running prereq checks"
    for cmd in "$@"; do
        printMsgNoNewline "${C_L_BLUE}.${T_RESET}"
        if ! _check_command_exists "$cmd"; then
            missing_commands+=("$cmd")
        fi
    done
    echo # Newline after the dots

    if [[ ${#missing_commands[@]} -gt 0 ]]; then
        clear_lines_up 1
        printErrMsg "Prerequisite checks failed. Missing commands:"
        for cmd in "${missing_commands[@]}"; do
            printMsg "    - ${C_L_YELLOW}${cmd}${T_RESET}"
        done
        printMsg "${T_INFO_ICON} Please install the missing commands and try again."
        exit 1
    fi
    clear_lines_up 1
}

# Gets the correct Docker Compose command ('docker compose' or 'docker-compose').
# Assumes prerequisites have been checked by check_docker_prerequisites.
# Usage:
#   local compose_cmd
#   compose_cmd=$(get_docker_compose_cmd)
#   $compose_cmd up -d
get_docker_compose_cmd() {
    if _check_command_exists "docker" && docker compose version &>/dev/null; then
        echo "docker compose"
    elif _check_command_exists "docker-compose"; then
        echo "docker-compose"
    else
        # This case should not be reached if check_docker_prerequisites was called.
        printErrMsg "Could not determine Docker Compose command." >&2
        exit 1
    fi
}

# Prompts the user with a Yes/No question and returns an exit code.
# Usage:
#   if prompt_yes_no "Do you want to proceed?"; then
#       # User said Yes
#   else
#       # User said No
#   fi
#   if prompt_yes_no "Do you want to proceed?" "y"; then
#       # User said Yes (or pressed Enter for default Yes)
#   else
#       # User said No (or pressed Enter for default No)
#   fi
# Arguments:
#   $1 - The question to ask the user.
#   $2 - The default answer ('y' or 'n'). Optional.
# Returns:
#   0 (success) if the user answers Yes (or default is 'y' and user presses Enter).
#   1 (failure) if the user answers No (or default is 'n' and user presses Enter).
prompt_yes_no() {
    local question="$1"
    local default_answer="${2:-}" # Optional second argument
    local prompt_suffix
    local answer

    # Determine the prompt suffix based on the default
    if [[ "$default_answer" == "y" ]]; then
        prompt_suffix="(Y/n)"
    elif [[ "$default_answer" == "n" ]]; then
        prompt_suffix="(y/N)"
    else
        prompt_suffix="(y/n)"
    fi

    while true; do
        printMsgNoNewline "${T_QST_ICON} ${question} ${prompt_suffix} "
        answer=$(read_single_char)
        
        # If the answer is the ENTER key, use the default.
        if [[ "$answer" == "$KEY_ENTER" ]]; then
            answer="$default_answer"
        fi

        case "$answer" in
            [Yy])
                clear_current_line
                return 0 # Success (Yes)
                ;;
            [Nn])
                clear_current_line
                return 1 # Failure (No)
                ;;
            *)
                clear_current_line
                printErrMsg "Invalid input. Please enter 'y' or 'n'."
                # Loop will continue.
                ;;
        esac
    done
}

# Prompts the user to press any key to continue, then clears the prompt.
# This is a blocking call that waits for a single keypress, making for a
# clean user experience by pausing the script and then removing the message.
# Usage:
#   prompt_to_continue
prompt_to_continue() {
    printInfoMsg "Press any key to continue..." >/dev/tty
    # -s: silent, -n 1: read 1 char, -r: raw
    # We redirect to /dev/tty to ensure it works even if stdout is captured.
    read -rsn1 </dev/tty
    # Clear the "Press any key..." message.
    clear_lines_up 1
}

##
# Displays an interactive multi-select menu.
# Allows the user to select multiple options using arrow keys and the spacebar.
#
# ## Usage:
#   local -a options=("All" "Option 1" "Option 2" "Option 3")
#   # if "All" is provided it enables toggling of all elements
#   local menu_output
#   menu_output=$(interactive_multi_select_menu "Select items:" "${options[@]}")
#   local exit_code=$?
#
#   if [[ $exit_code -eq 0 ]]; then
#     mapfile -t selected_indices <<< "$menu_output"
#     echo "You selected the following options:"
#     for index in "${selected_indices[@]}"; do
#       echo " - ${options[index]} (index: $index)"
#     done
#   else
#     echo "No options were selected or the selection was cancelled."
#   fi
#
# ## Arguments:
#  $1 - The prompt to display to the user.
#  $@ - The list of options for the menu.
#       If "All" is the first entry, it enables toggling of all elements
#
# ## Returns:
#  On success (Enter pressed with selections):
#    - Prints the indices of the selected options to stdout, one per line.
#    - Returns with exit code 0.
#  On cancellation (ESC or q pressed) or no selection:
#    - Prints nothing to stdout.
#    - Returns with exit code 1.
##
interactive_multi_select_menu() {
    # Ensure the script is running in an interactive terminal
    # When called via command substitution `$(...)`, stdout is not a tty.
    # We must check stdin (`-t 0`) instead and redirect all interactive
    # output to `/dev/tty` to ensure it appears on the user's screen.
    if ! [[ -t 0 ]]; then
        printErrMsg "Not an interactive session." >&2
        return 1
    fi

    local prompt="$1"
    shift
    local -a options=("$@")
    local num_options=${#options[@]}

    if [[ $num_options -eq 0 ]]; then
        printErrMsg "No options provided to menu." >&2
        return 1
    fi

    # State variables
    local current_option=0 # The currently highlighted option index
    local -a selected_options=()
    for ((i=0; i<num_options; i++)); do
        selected_options[i]=0
    done

    # If the first option is "All", enable special select/deselect all behavior.
    local has_all_option=false
    if [[ "${options[0]}" == "All" ]]; then
        has_all_option=true
    fi

    # Helper function to build the menu as a single string for faster rendering.
    _build_menu_output() {
        local output=""
        output+="${T_QST_ICON} ${prompt}\n"
        output+="    ${C_WHITE}(Use ${C_L_CYAN}↑ ↓${C_WHITE} to navigate, ${C_L_CYAN}space${C_WHITE} to select, ${C_L_GREEN}enter${C_WHITE} to confirm, ${C_L_YELLOW}q/esc${C_WHITE} to cancel)${T_RESET}\n"
        for i in "${!options[@]}"; do
            local pointer=" "
            local checkbox="[ ]"
            local highlight_start=""
            local highlight_end=""

            if [[ ${selected_options[i]} -eq 1 ]]; then
                checkbox="${C_GREEN}${T_BOLD}[✓]${T_RESET}"
            fi

            if [[ $i -eq $current_option ]]; then
                pointer="${T_BOLD}${C_L_MAGENTA}❯${T_RESET}"
                highlight_start="${T_REVERSE}"
                highlight_end="${T_RESET}"
            fi

            output+="  ${pointer} ${highlight_start}${checkbox} ${options[i]}${highlight_end}${T_RESET}${T_CLEAR_LINE}\n"
        done
        echo -e "$output"
    }

    # Hide cursor and set a trap to restore it on exit
    printMsgNoNewline "${T_CURSOR_HIDE}" >/dev/tty
    trap 'printMsgNoNewline "${T_CURSOR_SHOW}" >/dev/tty' EXIT

    # Initial draw of the menu
    local menu_output
    menu_output=$(_build_menu_output)
    echo -ne "$menu_output" >/dev/tty

    local key
    local menu_height=$((num_options + 2)) # +2 for prompt and help line

    while true; do
        move_cursor_up "$menu_height"

        # Read from the controlling terminal, not stdin which might be redirected
        key=$(read_single_char </dev/tty)

        case "$key" in
            "$KEY_UP"|"k") current_option=$(( (current_option - 1 + num_options) % num_options ));;
            "$KEY_DOWN"|"j") current_option=$(( (current_option + 1) % num_options ));;
            ' '|"h"|"l") 
                selected_options[current_option]=$(( 1 - selected_options[current_option] ))

                if [[ "$has_all_option" == "true" ]]; then
                    if [[ $current_option -eq 0 ]]; then
                        # "All" was toggled, so set all other options to its state
                        local all_state=${selected_options[0]}
                        for i in "${!options[@]}"; do
                            selected_options[i]=$all_state
                        done
                    else
                        # Another item was toggled, update "All" status
                        local all_selected=1
                        # Loop from 1 to skip the "All" option itself
                        for ((i=1; i<num_options; i++)); do
                            if [[ ${selected_options[i]} -eq 0 ]]; then
                                all_selected=0
                                break
                            fi
                        done
                        selected_options[0]=$all_selected
                    fi
                fi
                ;;
            "$KEY_ENTER"|"$KEY_ESC"|"q")
                # Clear the menu from the screen before exiting the loop.
                clear_lines_down "$menu_height"

                if [[ "$key" == "$KEY_ENTER" ]]; then
                    break
                else
                    return 1
                fi
                ;;
        esac
        # Redraw the menu with updated state
        menu_output=$(_build_menu_output)
        echo -ne "$menu_output" >/dev/tty
    done

    local has_selection=0
    for i in "${!options[@]}"; do
        if [[ ${selected_options[i]} -eq 1 ]]; then
            has_selection=1
            echo "$i"
        fi
    done

    if [[ $has_selection -eq 1 ]]; then
        return 0
    else
        return 1
    fi
}

##
# Displays an interactive single-select menu.
# Allows the user to select one option using arrow keys.
#
# ## Usage:
#   local -a options=("Option 1" "Option 2" "Option 3")
#   local selected_index
#   selected_index=$(interactive_single_select_menu "Select an item:" "${options[@]}")
#   local exit_code=$?
#
#   if [[ $exit_code -eq 0 ]]; then
#     echo "You selected index: $selected_index (${options[selected_index]})"
#   else
#     echo "No option was selected."
#   fi
#
# ## Arguments:
#  $1 - The prompt to display to the user.
#  $@ - The list of options for the menu.
#
# ## Returns:
#  On success (Enter pressed):
#    - Prints the index of the selected option to stdout.
#    - Returns with exit code 0.
#  On cancellation (ESC or q pressed):
#    - Prints nothing to stdout.
#    - Returns with exit code 1.
##
interactive_single_select_menu() {
    if ! [[ -t 0 ]]; then
        printErrMsg "Not an interactive session." >&2
        return 1
    fi

    local prompt="$1"
    shift
    local -a options=("$@")
    local num_options=${#options[@]}

    if [[ $num_options -eq 0 ]]; then
        printErrMsg "No options provided to menu." >&2
        return 1
    fi

    local current_option=0

    _build_menu_output() {
        local output=""
        output+="${T_QST_ICON} ${prompt}\n"
        output+="    ${C_WHITE}(Use ${C_L_CYAN}↑ ↓${C_WHITE} to navigate, ${C_L_GREEN}enter${C_WHITE} to confirm, ${C_L_YELLOW}q/esc${C_WHITE} to cancel)${T_RESET}\n"
        for i in "${!options[@]}"; do
            local pointer=" "
            local highlight_start=""
            local highlight_end=""
            
            if [[ $i -eq $current_option ]]; then
                pointer="${T_BOLD}${C_L_MAGENTA}❯${T_RESET}"
                highlight_start="${T_REVERSE}"
                highlight_end="${T_RESET}"
            fi
            output+="  ${pointer} ${highlight_start}${options[i]}${highlight_end}${T_RESET}${T_CLEAR_LINE}\n"
        done
        echo -e "$output"
    }

    printMsgNoNewline "${T_CURSOR_HIDE}" >/dev/tty
    trap 'printMsgNoNewline "${T_CURSOR_SHOW}" >/dev/tty' EXIT

    # Initial draw of the menu
    local menu_output
    menu_output=$(_build_menu_output)
    echo -ne "$menu_output" >/dev/tty

    local key
    local menu_height=$((num_options + 2))

    while true; do
        move_cursor_up "$menu_height"

        # Read from the controlling terminal, not stdin which might be redirected
        key=$(read_single_char </dev/tty)

        case "$key" in
            "$KEY_UP"|"k") current_option=$(( (current_option - 1 + num_options) % num_options ));;
            "$KEY_DOWN"|"j") current_option=$(( (current_option + 1) % num_options ));;
            "$KEY_ENTER")
                clear_lines_down "$menu_height"
                echo "$current_option"
                return 0
                ;;
            "$KEY_ESC"|"q")
                clear_lines_down "$menu_height"
                return 1
                ;;
        esac
        # Redraw the menu with updated state
        menu_output=$(_build_menu_output)
        echo -ne "$menu_output" >/dev/tty
    done
}

# Ensures the script is running from its own directory.
# This is useful for scripts that need to find relative files (e.g., docker-compose.yml).
# It uses BASH_SOURCE[1] to get the path of the calling script.
ensure_script_dir() {
    # BASH_SOURCE[1] is the path to the calling script.
    # This is more robust than passing BASH_SOURCE[0] as an argument.
    local SCRIPT_DIR
    SCRIPT_DIR=$( cd -- "$( dirname -- "${BASH_SOURCE[1]}" )" &> /dev/null && pwd )

    # If SCRIPT_DIR is empty, it means the cd in the subshell failed.
    if [[ -z "$SCRIPT_DIR" ]]; then
        printErrMsg "Could not access script directory from path: ${BASH_SOURCE[1]}"
        return 1
    fi

    if [[ "$PWD" != "$SCRIPT_DIR" ]]; then
        printMsg "${T_INFO_ICON} Changing to script directory: ${C_L_BLUE}${SCRIPT_DIR}${T_RESET}"
        cd "$SCRIPT_DIR" || return 1
    fi
}

# (Private) Finds the project root directory by searching upwards for a known file.
# The result is stored in the global variable _PROJECT_ROOT and exported.
# Returns 0 on success, 1 on failure.
_find_project_root() {
    # If already found, return success
    if [[ -n "$_PROJECT_ROOT" ]]; then
        return 0
    fi

    # Start searching from the directory of the top-level script that was executed.
    local start_dir
    start_dir=$(dirname "${BASH_SOURCE[-1]}")

    local current_dir
    current_dir=$(cd "$start_dir" && pwd)

    while [[ "$current_dir" != "/" && "$current_dir" != "" ]]; do
        # Using README.md and shared.sh as anchor files to identify the project root.
        if [[ -f "$current_dir/README.md" && -f "$current_dir/shared.sh" ]]; then
            _PROJECT_ROOT="$current_dir"
            export _PROJECT_ROOT # Export so subshells can see it
            return 0
        fi
        current_dir=$(dirname "$current_dir")
    done

    return 1 # Failed to find root
}

# (Private) Validates the format of a .env file.
# It prints a detailed error and returns 1 on the first invalid line found.
# Returns 0 if the entire file is valid.
# Usage:
#   if ! _validate_env_file "/path/to/.env"; then
#       # Handle validation failure
#   fi
_validate_env_file() {
    local env_file_path="$1"
    local line_num=0

    while IFS= read -r line || [[ -n "$line" ]]; do
        ((line_num++))
        local trimmed_line
        trimmed_line=$(echo "$line" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')

        if [[ -z "$trimmed_line" || "$trimmed_line" =~ ^# ]]; then
            continue
        fi

		local error_reason=""
		# Rule 1: Must contain an equals sign.
		if ! [[ "$trimmed_line" =~ = ]]; then
			error_reason="Missing '=' in '${trimmed_line}'"
		# Rule 2: Must not have spaces immediately surrounding the equals sign.
		elif [[ "$trimmed_line" =~ [[:space:]]=|=[[:space:]] ]]; then
			error_reason="Found spaces around '=' in '${trimmed_line}'"
		# Rule 3: The key must be a valid shell variable name.
		elif ! [[ "$trimmed_line" =~ ^[a-zA-Z_][a-zA-Z0-9_]*= ]]; then
			error_reason="Invalid variable name in '${trimmed_line}'"
		fi

		if [[ -n "$error_reason" ]]; then
            printErrMsg "Found an error in ${C_L_BLUE}${env_file_path}${T_RESET} on line ${line_num}."
            printMsg "    ${T_ERR_ICON} ${error_reason}"
            printInfoMsg "Expecting 'VARIABLE=VALUE' (no spaces around equals sign)."
            return 1
        fi
    done <"$env_file_path"
    return 0
}

# Sources a specified .env file if it exists and exports its variables.
# It also prints the variables that were found and sourced.
# Usage: load_project_env "/path/to/your/.env"
load_project_env() {
	local env_file_path="$1"
	if [[ ! -f "$env_file_path" ]]; then
		return 0 # Not an error if the file doesn't exist
	fi

    # Validate the file first. The helper function will print detailed errors.
    if ! _validate_env_file "$env_file_path"; then
        return 1
    fi

    # File is valid, now get the variable names for the success message.
    local valid_vars=()
    while IFS= read -r line || [[ -n "$line" ]]; do
        local trimmed_line
        trimmed_line=$(echo "$line" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')
        if [[ -z "$trimmed_line" || "$trimmed_line" =~ ^# ]]; then
            continue
        fi
        valid_vars+=("${trimmed_line%%=*}")
    done <"$env_file_path"

	# If there are variables to source, print the message and source them.
	if [[ ${#valid_vars[@]} -gt 0 ]]; then
		# printInfoMsg "Sourcing environment variables from ${C_L_BLUE}${env_file_path}${T_RESET}"
		# local pretty_vars
		# pretty_vars=$(printf ", %s" "${valid_vars[@]}")
		# printMsg "    Found: ${C_L_CYAN}${pretty_vars:2}${T_RESET}"

		set -a
		# shellcheck source=/dev/null
		source "$env_file_path"
		set +a
	fi
}

# Checks if the script is run as root. If not, it prints a message
# and re-executes the script with sudo.
# Usage: ensure_root "Reason why root is needed." "$@"
ensure_root() {
    local reason_msg="$1"
    shift # The rest of "$@" are the original script arguments.
    if [[ $EUID -ne 0 ]]; then
        printMsg "${T_INFO_ICON} ${reason_msg}"
        #printMsg "    ${C_L_BLUE}Attempting to re-run with sudo...${T_RESET}"
        exec sudo bash "${BASH_SOURCE[1]}" "$@"
    fi
}

# Helper to show systemd logs and exit on failure.
show_logs_and_exit() {
    local message="$1"
    printErrMsg "$message"
    # Check if journalctl is available before trying to use it.
    if _check_command_exists "journalctl"; then
        printMsg "    ${T_INFO_ICON} Preview of system log:"
        # Indent the journalctl output for readability
        journalctl -u ollama.service -n 10 --no-pager | sed 's/^/    /'
    else
        printMsg "    ${T_WARN_ICON} 'journalctl' not found. Cannot display logs."
    fi
    exit 1
}

# Polls a given URL until it gets a successful HTTP response or times out.
# Usage: poll_service <url> <service_name> [timeout_seconds]
poll_service() {
    local url="$1"
    local service_name="$2"
    # The number of tries is based on the timeout in seconds.
    # We poll once per second.
    local tries=${3:-10} # Default to 10 tries (10 seconds)

    local desc="Waiting for ${service_name} to respond at ${url}"

    # We need to run the loop in a subshell so that `run_with_spinner` can treat it
    # as a single command. The subshell will exit with 0 on success and 1 on failure.
    # We pass 'url' and 'tries' as arguments to the subshell to avoid quoting issues.
    if run_with_spinner "${desc}" bash -c '
        url="$1"
        tries="$2"
        for ((j=0; j<tries; j++)); do
            # Use a short connect timeout for each attempt
            if curl --silent --fail --head --connect-timeout 2 "$url" &>/dev/null; then
                exit 0 # Success
            fi
            sleep 1
        done
        exit 1 # Failure
    ' -- "$url" "$tries"; then
        clear_lines_up 1
        return 0
    else
        printErrMsg "${service_name} is not responding at ${url}"
        return 1
    fi
}

# Checks if an endpoint is responsive without writing to terminal
# Returns 0 on success, 1 on failure.
# Usage: check_endpoint_status <url> [timeout_seconds]
check_endpoint_status() {
    local url="$1"
    local timeout=${2:-5} # A shorter default timeout is fine for a status check.
    # Use --connect-timeout to fail fast if the port isn't open.
    # Use --max-time for the total operation.
    if curl --silent --fail --head --connect-timeout 2 --max-time "$timeout" "$url" &>/dev/null; then
        return 0 # Success
    else
        return 1 # Failure
    fi
}

# Cached check to see if this is a systemd-based system.
# The result is stored in a global variable to avoid repeated checks.
# Returns 0 if systemd, 1 otherwise.
_is_systemd_system() {
    # If the check has been run, return the cached result.
    if [[ -n "$_IS_SYSTEMD" ]]; then
        return "$_IS_SYSTEMD"
    fi

    # Check for the presence of systemctl and that systemd is the init process.
    # `is-system-running` can fail on a "degraded" system, which is still usable.
    # Checking for the /run/systemd/system directory is a more reliable way to detect systemd.
    if _check_command_exists "systemctl" && [ -d /run/systemd/system ]; then
        _IS_SYSTEMD=0 # true
    else
        _IS_SYSTEMD=1 # false
    fi
    return "$_IS_SYSTEMD"
}

# Checks if a given service is known to systemd.
# Assumes _is_systemd_system() has been checked.
# Usage: _is_systemd_service_known <service_name>
# Returns 0 if found, 1 otherwise.
_is_systemd_service_known() {
    local service_name="$1"
    # 'systemctl cat' is a direct way to check if a service exists
    # It will return a non-zero exit code if the service doesn't exist.
    # We redirect stdout and stderr to /dev/null to suppress all output.
    if systemctl cat "${service_name}" &>/dev/null; then
        return 0 # Found
    else
        return 1 # Not found
    fi
}

# Public-facing check if a given systemd service exists.
# Usage: check_systemd_service_exists <service_name>
# Returns 0 if it exists, 1 otherwise.
check_systemd_service_exists() {
    local service_name="$1"
    if ! _is_systemd_system || ! _is_systemd_service_known "${service_name}"; then
        return 1
    fi
    return 0
}

# (Private) The core logic for non-interactive mode (e.g., in CI/CD).
# Runs a command, captures its output, and prints a simple status.
# Arguments:
#   $1 - Description of the task.
#   $@ - The command and its arguments.
# Returns: The exit code of the command.
# Sets global SPINNER_OUTPUT.
_run_with_spinner_non_interactive() {
    local desc="$1"
    shift
    local cmd=("$@")

    printMsgNoNewline "${desc} " >&2
    # Run the command in the foreground, capturing its output.
    # The `if` statement checks the exit code of the command substitution.
    if SPINNER_OUTPUT=$("${cmd[@]}" 2>&1); then
        echo -e "${C_L_GREEN}Done.${T_RESET}" >&2
        return 0
    else
        local exit_code=$?
        echo -e "${C_RED}Failed.${T_RESET}" >&2
        # Print the captured error output for debugging in non-interactive environments.
        while IFS= read -r line; do
            printf '    %s\n' "$line"
        done <<< "$SPINNER_OUTPUT" >&2
        return $exit_code
    fi
}

# (Private) The core logic for the interactive spinner.
# Runs a command in the background, shows an animation, and captures output.
# Arguments:
#   $1 - Description of the task.
#   $@ - The command and its arguments.
# Returns: The exit code of the command.
# Sets global SPINNER_OUTPUT.
_run_with_spinner_interactive() {
    local desc="$1"
    shift
    local cmd=("$@")
    local temp_output_file
    temp_output_file=$(mktemp)
    if [[ ! -f "$temp_output_file" ]]; then
        printErrMsg "Failed to create a temporary file with mktemp." >&2
        printMsg "    ${T_INFO_ICON} This can be caused by permission issues in /tmp or if 'mktemp' is not installed." >&2
        return 1
    fi

    local spinner_chars="⣾⣷⣯⣟⡿⢿⣻⣽"
    local i=0

    # Run the command in the background, redirecting its output to the temp file.
    "${cmd[@]}" &> "$temp_output_file" &
    local pid=$!

    # Hide cursor and set a trap to restore it on exit or interrupt.
    tput civis
    trap 'tput cnorm; rm -f "$temp_output_file"; exit 130' INT TERM

    while ps -p $pid > /dev/null; do
        echo -ne "\r\e[2K" >&2 # Clear the current line
        local current_output_line
        current_output_line=$(tail -n 1 "$temp_output_file" 2>/dev/null | tr -d '\r' || true)
        echo -ne " ${C_L_BLUE}${spinner_chars:$i:1}${T_RESET}  ${desc}" >&2
        if [[ -n "$current_output_line" ]]; then
            echo -ne " ${C_GRAY}[${current_output_line:0:70}]${T_RESET}" >&2
        fi
        i=$(((i + 1) % ${#spinner_chars}))
        sleep 0.1
    done

    # Wait for the command to finish and get its exit code
    wait $pid
    local exit_code=$?

    # Read the output from the temp file into the global variable
    SPINNER_OUTPUT=$(<"$temp_output_file")
    rm "$temp_output_file"

    # Show cursor again and clear the trap
    tput cnorm
    trap - INT TERM

    # Overwrite the spinner line with the final status message
    clear_current_line >&2
    if [[ $exit_code -eq 0 ]]; then
        printOkMsg "${desc}" >&2
    else
        printErrMsg "Task failed: ${desc}" >&2
        while IFS= read -r line; do
            printf '    %s\n' "$line"
        done <<< "$SPINNER_OUTPUT" >&2
    fi
    return $exit_code
}

# A function to display a spinner while a command runs in the background.
# It detects if it's running in an interactive terminal and disables the
# spinner animation if it's not, falling back to simpler output.
# Usage: run_with_spinner "Description of task..." "command_to_run" "arg1" "arg2" ...
# The command's stdout and stderr will be captured.
# The function returns the exit code of the command.
# The captured stdout is stored in the global variable SPINNER_OUTPUT.
SPINNER_OUTPUT=""
run_with_spinner() {
    if [[ ! -t 1 ]]; then
        _run_with_spinner_non_interactive "$@"
    else
        _run_with_spinner_interactive "$@"
    fi
}

# A function to display a spinner while waiting for a list of background PIDs to complete.
# It detects if it's running in an interactive terminal and falls back to simpler output if not.
# Usage: wait_for_pids_with_spinner "Description of task..." pid1 pid2 ...
# The function returns the exit code of the `wait` command.
wait_for_pids_with_spinner() {
    local desc="$1"
    shift
    local pids_to_wait_for=("$@")

    # Non-interactive mode
    if [[ ! -t 1 ]]; then
        printMsgNoNewline "    ${T_INFO_ICON} ${desc}... " >&2
        # In non-interactive mode, just wait without a spinner.
        # The `wait` command will return a non-zero status only if one of the PIDs
        # is not a valid child process, not if the child process itself fails.
        if wait "${pids_to_wait_for[@]}"; then
            echo -e "${C_L_GREEN}Done.${T_RESET}" >&2
            return 0
        else
            local exit_code=$?
            echo -e "${C_RED}Failed (wait command exit code: $exit_code).${T_RESET}" >&2
            return $exit_code
        fi
    fi

    # Interactive mode
    _spinner() {
        local spinner_chars="⣾⣷⣯⣟⡿⢿⣻⣽"
        local i=0
        while true; do
            echo -ne "\r\e[2K" >&2
            echo -ne "    ${C_L_BLUE}${spinner_chars:$i:1}${T_RESET} ${desc}" >&2
            i=$(((i + 1) % ${#spinner_chars}))
            sleep 0.1
        done
    }

    tput civis
    _spinner &
    local spinner_pid=$!

    # Set a trap to clean up the spinner if the script is interrupted.
    # This trap is local to this function call.
    trap 'kill "$spinner_pid" &>/dev/null; tput cnorm; exit 130' INT TERM

    # Wait for all the specified PIDs in the foreground.
    # The spinner runs in the background.
    wait "${pids_to_wait_for[@]}"
    local exit_code=$?

    # Clean up the spinner and the trap
    kill "$spinner_pid" &>/dev/null
    tput cnorm
    trap - INT TERM # remove the temporary trap

    clear_current_line >&2
    if [[ $exit_code -eq 0 ]]; then
        printOkMsg "${desc}" >&2
    else
        printErrMsg "Wait command failed with exit code ${exit_code} for task: ${desc}" >&2
    fi
    return $exit_code
}

# --- Test Framework ---
# These are not 'local' so the helper functions can access them.
test_count=0 # Global test counter
failures=0   # Global failure counter

# Initializes or resets the test suite counters.
# This should be called at the beginning of any `run_tests` function.
initialize_test_suite() {
    test_count=0
    failures=0
}

# (Private) Helper to run a single string comparison test case.
# Usage: _run_string_test "actual_output" "expected_output" "description"
_run_string_test() {
    local actual="$1"
    local expected="$2"
    local description="$3"
    ((test_count++))

    if [[ "$actual" == "$expected" ]]; then
        _test_passed "${description}"
    else
        # Sanitize output for printing to prevent control characters from
        # messing up the terminal output. `printf %q` is perfect for this.
        local sanitized_expected sanitized_actual
        sanitized_expected=$(printf '%q' "$expected")
        sanitized_actual=$(printf '%q' "$actual")
        _test_failed "${description}"
        printErrMsg "    Expected: ${sanitized_expected}"
        printErrMsg "    Got:      ${sanitized_actual}"
        ((failures++))
    fi
}

# (Private) Helper to run a single return code test case.
# Usage: _run_test "command_to_run" <expected_code> "description"
_run_test() {
    local cmd_string="$1"
    local expected_code="$2"
    local description="$3"
    ((test_count++))

    # Run command in a subshell to not affect the test script's state,
    # and capture its stdout and stderr.
    local output
    output=$(eval "$cmd_string" 2>&1)
    local actual_code=$?

    if [[ $actual_code -eq $expected_code ]]; then
        _test_passed "${description}"
    else
        _test_failed "${description}" "Expected: ${expected_code}, Got: ${actual_code}"
        # Print the captured output on failure for debugging
        if [[ -n "$output" ]]; then
            while IFS= read -r line; do
                printf '    %s\n' "$line"
            done <<< "$output"
        fi
        ((failures++))
    fi
}

# (Private) Helper to run a single test case for the compare_versions function.
# It is defined at the script level to ensure it's available when called.
# It accesses the `test_count` and `failures` variables from its caller's scope.
# Usage: _run_compare_versions_test "v1" "v2" <expected_code> "description"
_run_compare_versions_test() {
    local v1="$1"
    local v2="$2"
    local expected_code="$3"
    local description="$4"
    ((test_count++))

    compare_versions "$v1" "$v2"
    local actual_code=$?
    if [[ $actual_code -eq $expected_code ]]; then
        _test_passed "${description}"
    else
        _test_failed "${description}" "Expected: ${expected_code}, Got: ${actual_code}"
        ((failures++))
    fi
}

# (Private) Helper to print a passing test message.
# Usage: testPassed "description"
_test_passed() {
    printOkMsg "${C_L_GREEN}PASS${T_RESET}: ${1}"
}

# (Private) Helper to print a failing test message.
# Usage: testFailed "description" ["additional_info"]
_test_failed() {
    local description="$1"
    local additional_info="$2"
    if [[ -n "$additional_info" ]]; then
        printErrMsg "${C_L_RED}FAIL${T_RESET}: ${description} (${additional_info})"
    else
        printErrMsg "${C_L_RED}FAIL${T_RESET}: ${description}"
    fi
}

# Prints summary for test suite.
# Reads global variables 'test_count' and 'failures'.
# Exits with 0 on success and 1 on failure.
# Usage:
#   print_test_summary "mock_function1" "mock_function2" ...
# Arguments:
#   $@ - Optional list of mock function names to unset before exiting.
print_test_summary() {
    printTestSectionHeader "Test Summary"

    if [[ $failures -eq 0 ]]; then
        printOkMsg "All ${test_count} tests passed!"
    else
        printErrMsg "${failures} of ${test_count} tests failed."
    fi

    # Unset any mock functions passed as arguments
    if [[ $# -gt 0 ]]; then
        # The -f flag is important to unset functions.
        # Using -- prevents arguments like "-f" from being interpreted as options.
        # Redirecting stderr to /dev/null suppresses "not found" errors if a mock
        # wasn't defined (e.g., due to a test suite being skipped).
        unset -f -- "$@" &>/dev/null
    fi

    if [[ $failures -eq 0 ]]; then exit 0; else exit 1; fi
}

# Checks for Docker and Docker Compose. Exits if not found.
# Usage: check_docker_prerequisites [--silent]
#   --silent: If provided, success messages will be cleared instead of printed.
check_docker_prerequisites() {
    local silent=false
    if [[ "$1" == "--silent" ]]; then
        silent=true
    fi

    printMsgNoNewline "${T_INFO_ICON} Checking for Docker... " >&2
    if ! _check_command_exists "docker"; then
        echo >&2 # Newline before error message
        printErrMsg "Docker is not installed. Please install Docker to continue." >&2
        exit 1
    fi
    if $silent; then
        clear_current_line >&2
    else
        printOkMsg "Docker is installed." >&2
    fi

    printMsgNoNewline "${T_INFO_ICON} Checking for Docker Compose... " >&2
    # Check for either v2 (plugin) or v1 (standalone)
    if ! (_check_command_exists "docker" && \
            docker compose version &>/dev/null) && \
        ! _check_command_exists "docker-compose"; then
        echo >&2 # Newline before error message
        printErrMsg "Docker Compose is not installed." >&2
        exit 1
    fi
    if $silent; then
        clear_current_line >&2
    else
        printOkMsg "Docker Compose is available." >&2
    fi
}
